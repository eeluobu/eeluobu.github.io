---
layout:     post
title:      "C++之面向对象"
subtitle:   "C++语言的面向对象编程"
date:       2016-05-21
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - C++
    - 面向对象
---

主要介绍一些面试常问到的问题，比较基础的知识，不过有些还是常常容易被忽略。首先介绍一下标准模板库，以及C++中常用的一些容器。对于面向对象，必不可少的当然是类，介绍一下class的成员函数以及它和struct的区别。然后类中的构造函数、析构函数、赋值函数等，最后会提一下多态和友元。


### STL和容器

STL为标准模板库，模板是类或函数的宏，又叫做泛型类或者泛型函数。


#### 容器

容器（container），可以容纳一些数据的模板类。STL中有vector、set、map和deque等容器。 vector 和 deque 提供对元素的**快速随机访问**，但在任意位置插入或删除元素比在尾部开销大。 list 在任何位置都能**快速插入和删除**，但随机访问开销较大。

下面是关于vector容器的一些操作。

``` c
vector<int> vec;
vec.push_back(t);  //在尾部插入一个元素t

vector<int>::iterator p;
p = vec.begin();   //定义一个迭代器p指向vec的第一个元素
                   //end为末端的下一个元素
                   //p为指针，对指向的元素赋值可以通过*p来实现
                   
vec.erase(p);    //删除第一个元素
vec.pop_back();  //删除最后一个元素
```

举个例子，下面的程序将vec的元素遍历并赋值0。

``` c
for(vector<int>::iterator p = vec.begin(); p != vec.end(), p++)
    *p = 0;
    
//使用下标来实现
for(vector<int>::size_type i = 0; i != vec.size(); i++)
    vec[i] = 0;
```



map容器的类型

``` c
map<k, v>::key_type    //键类型
map<k, v>::mapped_type //值类型
map<k, v>::value_type  //这是一个pair类型，first为const常量键类型，second为值类型。
```


下面的代码用来统计输入的每个单词的数量

``` c
map<string, int> word_count;
string word;
while(cin >> word)
    ++word_count[word];
```


#### 泛型编程

对于标准容器，要想实现对容器的查找、排序等操作，可以标准库中定义的一组**泛型算法**来实现，对于不同的容器都是相同的操作。就像数学里面，好多定理都需要依赖同一套公理一样。整个STL就是泛型编程的一个例子。


如下，作为例子编写的一个泛型查找函数

``` c
template<typename T>
const T *find1(T *a, int n, T x)
{
    const T *p = a;
    for(int i = 0; i < n; i++)
    {
        if(*p == x)
            return p;
        p++;
    }
    return 0;
}

//原型
const int *find1(const int *a, int n, int x)
{
    const int *p = a;
    for(int i = 0; i < n; i++)
    {
        if(*p == x)
            return p;
        p++;
    }
    return 0;
}
```

### 成员变量

类中的成员变量可以分为3种，分别为：

- `private` 只能由1、该类的成员函数；2、友元函数访问。不能被该类的对象访问。

- `protected` 可以被1、该类的成员函数；2、友元函数；3、子类的函数访问。不能被该类的对象访问。

- `public` 可以被1、该类的成员函数；2、友元函数；3、子类的函数；4、该类的对象访问。


如果需要访问类中的 private 数据，可以在通过类中的共有函数的返回值来调用。

在class中变量默认的是private，struct中变量默认的是public，其他方面，两者区别很小。

### 成员函数

成员函数在类中占很重要的位置，下面将介绍class中最基础的几个成员函数。为了方便起见，以一个模拟的 String 类作为例子，然后在下面列举出详细的成员函数实现。 String 的原型：

``` c
class String
{
    public:
    String(const char *str = NULL);          //构造函数
    String(const String &other);             //复制构造函数
    ~String(void);                          //析构函数
    String& operate = (const String &other); //赋值函数
    
    private:
    char *m_data;     //用于保存字符串
};
``` 


#### 构造函数

只要创建类的一个新的对象，就要执行构造函数。构造函数的作用是保证每个对象的数据成员都具有合适的初始值。


``` c
String::String(const char *str)
{
    if(str == NULL)
    {
        m_data = new char[1];
        *m_data = '\0';
    }
    else
    {
        m_data = new char[strlen(str)+1];
        strcpy(m_data, str);
    }
}
```

然后就可以用下面的语句，创建并初始化一个新的String对象了

``` c
String str("hello!");
```

#### 析构函数

在构造函数中分配了资源之后，就需要析构函数来回收或者释放这些资源。撤销类对象时会自动调用析构函数。当然析构函数的作用不仅限于释放资源，只要是需要在该类的对象使用完毕后执行的程序都可以。


``` c
String::~String(void)
{
    delete[] m_data;
    //也可以写成delete m_data
}
```

这个析构函数是为了防止内存泄漏的，当一个String对象超出了它的作用域时，会运行这个析构函数。

#### 复制构造函数

复制构造函数是一个特殊的构造函数，只有一个形参，该形参是对该类对象的引用，形参常用const修饰。


`注意` 大多数类应定义复制构造函数和默认构造函数，否则会严重局限类的使用。

``` c
String::String(const String &other)
{
    m_data = new char[strlen(other.m_data)+1];
    strcpy(m_data, other.m_data);
}
```

复制构造函数定义好之后，下面的语句就能够起到将 s1 复制给 s2 的作用了

``` c
String s1("hello");
String s2(s1);
```

#### 赋值运算符函数

合成的赋值运算符函数和合成复制构造函数操作类似，会执行**逐个成员赋值**，不过本例中只有一个成员变量m_data。返回的 this 为指向左操作数的指针，右操作数一般为const引用传递。

``` c
String& String::operate = (const String &other)
{
    if(this == &other)
        return *this;
        
    delete[] m_data;
    m_data = NULL;
    
    m_data = new char[strlen(other.m_data)+1];
    strcpy(m_data, other.m_data);
    
    return *this;  //*this为左操作数的对象的引用
}
```

有了赋值运算符函数，就可以实现相应的String类赋值运算。如下例子实现s2的值赋给s1：

``` c
String s1("hello");
String s2("world");
s1 = s2;
```

C++ Primer 书上说的一个经验法则：如果类需要析构函数，则它也需要复制构造函数和赋值运算符函数。




### 多态

多态性可以简单的概括为“一个接口，多种方法”，在程序`运行的过程中`才决定调用的函数。多态性是面向对象编程的核心概念。多态性在C++中通过虚函数实现。


#### 虚函数

被 virtual 关键字修饰的成员函数，就是虚函数。作用是：指向基类的指针在操作它的多态类对象时，会根据不同的类对象，调用其相应的函数（虚函数）。下面的例子一看就明白了。


``` c
//没有使用虚函数时
class A
{
    public:
    void print() {cout<<"A"<<endl;}
}

class B : public A
{
    public:
    void print() {cout<<"B"<<endl;}
}

//测试程序1
//输出结果：A B
int main()
{
    A a;
    B b;
    a.print();
    b.print();
    return 0;
}

//测试程序2
//输出结果：A A
int main()
{
    A a;
    B b;
    A *p1 = &a;
    A *p2 = &b;
    p1->print();
    p2->print();
    return 0;
}


//使用虚函数，实现了多态
class A
{
    public:
    virtual void print() {cout<<"A"<<endl;}
}
class B : public A
{
    public:
    void print() {cout<<"B"<<endl;}       //此函数也为虚函数
}

//测试程序
//输出结果：A B
//和上面的测试程序1的输出相同了
int main()
{
    A a;
    B b;
    A *p1 = &a;
    A *p2 = &b;
    p1->print();
    p2->print();
    return 0;
}

```

上面的程序即体现了程序的多态，用一句话概括多态性，即允许将子类类型的指针赋值给父类类型的指针，父对象可以根据当前赋值给它的子对象的特性以不同的方式运作（调用不同类中的虚函数）。


#### 作用和用途




上面说到虚函数用来实现多态，虚函数总是在派生类中被改写，这种改写被称为覆盖，这也是覆盖（override）和函数的重载（overload）的区别。重载只是一种语法规则，不是面向对象编程，和多态无关。函数地址在**运行期间绑定**的才是多态。


关于代码重用，我们可以通过封装和继承来实现。对于接口的重用，则需要通过多态来实现了。





### 友元 


#### 作用


友元是定义在类外部的普通函数，只需要在类中加上 friend 并声明即可。友元解决的问题有，保持了类的私有数据的隐藏特性，同时又避免了多次调用成员函数造成的参数传递、类型检查等时间开销。

友元可以是普通的非成员函数，或者其他类的成员函数，还可以是整个类。一个类的private成员可以被其成员函数和其友元函数所使用。

#### 应用


模板类的友元重载

``` c
#include <iostream>
using namespace std;

template <class T>
ostream& operator << (ostream &out, const Test<T> &obj)
{
    out << obj.num;
    return out;
}

template <class T>
class Test
{
    private:
    int num;
    
    public:
    Test(int n = 0) {num = n;}                   //构造函数
    Test(const Test<T> &copy) {num = copy.num;}  //复制构造函数
    friend ostream& operator << <> (ostream &out, const Test<T> &obj);
};

int main()
{
    Test<int> t(2);
    cout << t;
    return 0;
}
```

