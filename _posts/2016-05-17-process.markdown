---
layout:     post
title:      "进程间通信"
subtitle:   "管道、信号、信号量、共享内存、消息队列"
date:       2016-05-17
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - 进程通信
---

### 管道

管道可用于具有亲缘关系进程间的通信。有名管道除了具有管道所有功能外，还允许无亲缘关系的进程间的通信。

#### 无名管道

创建无名管道函数pipe()

``` c
int pipe(int fd[2])
```

fd[0]为读管道，fd[1]为写管道。成功返回0，失败返回-1。

首先声明int pipe_fd[2]，在fork()之后，分别关闭父子进程的读端和写端，就能实现父子进程之间的单向通信。


#### 有名管道

有名管道创建mkfifo()

``` c
int mkfifo(const char *filename, mode_t mode)
```

`filename：`要创建的管道。

`mode：`O_RDONLY：读管道；O_WRONLY：写管道；O_RDWR：读写管道；O_NONBLOCK：非阻塞；O_CREAT：如果不存在，创建一个文件；O_EXCL：测试文件是否存在。


下面代码创建一个有名管道，等同于用“ `mknod 管道名 p` ”命令来创建的管道。

``` c
mkfifo("/tmp/管道名", 0666);
```

创建好后，可以在不同的程序中打开管道，打开的路径为" /tmp/管道名 "，然后读写即可。

`注意：`有名管道只需要创建一次即可，可以用access("/tmp/管道名", F_OK) 函数来判断管道是否已经存在。返回-1为不存在，需要在程序中创建。


### 信号

信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户进程发生了哪些系统事件。信号有4个重要事件：信号产生、信号在进程中注册、信号注销、执行信号处理函数。

对信号有3种处理方式

- 忽略信号，对信号不做任何处理，SIGKILL和SIGSTOP不能忽略。记得在之前的并发网络编程中，为了防止僵死进程的出现，就忽略了父进程对SIGCHLD的处理。

- 捕捉信号，当信号发生时，运行自定义信号处理函数。

- 默认操作，Linux对每个信号都有默认操作。

常见信号：


| 信号名   |                          含义                    | 默认操作 |
| :------: |            :----------------------:              | :------: | 
| SIGINT   | 用户键入INTR字符时发出（通常是Ctrl-C）           |  终止    | 
| SIGQUIT  | 和上一个类似，但由QUIT字符发出（通常是Ctrl-\）   |  终止    | 
| SIGKILL  | 用来立即结束进程，不能被阻塞、处理或忽略         |  终止    |
| SIGSTOP  | 用于暂停一个进程，不能被阻塞、处理或忽略         | 暂停进程 |
| SIGALARM | 当定时器到时时发出                               |  终止    |
| SIGSTP   | 交互停止进程，键入SUSP字符发出（通常是Ctrl-Z）   | 停止进程 |
| SIGCHLD  | 子进程结束时，父进程收到这个信号                 | 忽略     |



#### 信号发送

**kill()函数**

kill()函数不仅可以像kill命令一样中止进程（发送SIGKILL信号），也可以向进程发送其他信号。

``` c
int kill(pid_t pid, int sig)
```

`pid：` 正数：要发送信号的进程号；0：信号被发送到所有和当前进程在同一个进程组的进程；-1：信号发送给所有进程表中的进程；小于-1：信号发送给进程组号为-pid的每一个进程。

`sig：` 信号。

返回值：成功0，出错-1。

**raise()函数**

raise()向进程自身发送信号。

``` c
int raise(int sig)
```

sig：信号。返回值：成功0，出错-1。

**alarm()和pause()函数**

alarm()函数可以在进程中设定时间，当时间到达时，向进程发送SIGALARM信号。

pause()函数将进程挂起，直到`捕捉到`信号为止，通常用来判断信号是否已到。


``` c
unsigned int alarm(unsigned int seconds)
int pause(void)
```


#### 信号处理

下面是对信号进行处理的函数signal()

``` c
void (*signal(int signum, void (*handler)(int)))(int)
```

`signum：` 指定的信号。

`handler：` SIG_IGN：忽略该信号；SIG_DFL：默认方式处理；其他：自定义信号处理函数指针。

这个函数看起来比较复杂，该函数的返回值是一个无返回值带一个整形参数的函数，即信号的原始配置函数。接着就是它的两个参数了，一个是指定信号，一个自定义是处理函数指针。

相关的函数还有int sigaction()，在这里就不介绍了。下面是一个简单的操作例子

``` c
sigset_t set;
sigemptyset(&set);  //初始化信号集
sigaddset(&set, SIGQUIT);  //将信号添加到信号集中

struct sigaction a;
sigemptyset(&a.sa_mask);
a.sa_handler = my_fun;      //指定信号处理函数
sigaction(SIGQUIT, &a, NULL);  //指定要处理的信号，除了SIGKILL和SIGSTOP
```


### 信号量

`临界资源`是在同一个时刻只允许有限个进程可以访问或修改的资源，通常包括硬件资源（处理器、内存以及其他外围设备）和软件资源（共享代码段，共享结构和变量等）。访问临界资源的代码叫做`临界区`。控制对临界资源的访问就需要信号量和相应的操作了。

信号量值代表可用资源数量。`P操作：`如果有可用资源（信号量值 >0 ），信号量值减一，进入临界区；如果没有可用资源，被阻塞，直到系统将资源分配给该进程。`V操作：`如果该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞进程；如果没有进程等待，则释放一个资源，信号量值加一。


#### 创建

semget()函数可以用来创建信号量或者获得系统已存在的信号量。

``` c
int semget(key_t key, int nsems, int semflg)
```

`key：` 信号量的键值，多个进程可以通过它访问同一个信号量。IPC_PRIVATE用于创建当前进程的私有信号量，该进程的父子进程可访问。可以用` ftok("路径", '关键字') `函数来创建key。

`nsems：` 需要创建的信号量的数目，通常为1。

`semflg：` 同open()函数的权限位。

返回值：成功为信号量标识符，出错为-1。

#### 初始化

semctl()函数来初始化创建的信号量。

``` c
int semctl(int semid, int semnum, int cmd, union semun arg)
```

`semid：` semget()函数返回的信号量标识符。

`semnum：` 信号量编号，取0时使用单个信号量。

`cmd：` 指定对信号量的各种操作，当使用单个信号量时：IPC_STAT获得该信号量的semid_ds结构，存放在arg参数的*buf中；IPC_SETVAL将信号量设置为arg的val值；IPC_GETVAL返回信号量当前值；IPC_RMID删除信号量。

`arg：` 为union semun结构：

``` c
union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
}
```

返回值：成功：0（IPC_STAT、IPC_SETVAL、IPC_RMID）当前信号量值（IPC_GETVAL）；出错-1。

#### PV操作


semop()函数用来实现进程之间的互斥和同步操作。

``` c
int semop(int semid, struct sembuf *sops, size_t nsops)
```

`senid：` semget()函数返回的信号量标识符。

`*sops：` 指向信号量操作数组，数组中每个元素都是下面的一个结构体

``` c
struct sembuf()
{
    /* 信号量编号，使用单个信号量时，取0值 */
    short sem_num;
    
    /* 取值-1表示P操作，取值1表示v操作 */
    short sem_op;
    
    /* 通常设置SEM_UNDO，在进程退出时，系统自动释放未释放的信号量 */
    short sem_flg;
}
```

`nsops：` 操作数组sops中的元素数目，通常取值1。


返回值：成功：信号量标识符；出错：-1。

#### PV操作实例

下面的程序实现了在进程中初始化信号量、删除信号量、以及P操作和V操作，在实际使用时，只需要在程序中包含 sem_com.h 头文件即可。

``` c
/* sem_com.h */

#ifndef  SEM_COM_H
#define  SEM_COM_H

#include <sys/ipc.h>
#include <sys/sem.h>

union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int init_sem(int, int);
int del_sem(int);
int sem_p(int);
int sem_v(int); 

#endif 

/* sem_com.c */

#include "sem_com.h"

int init_sem(int sem_id, int init_value)
{
    union semun sem_union;
    sem_union.val = init_value;
    if (semctl(sem_id, 0, SETVAL, sem_union) == -1)
    {
        perror("Initialize semaphore");		
        return -1;
    }
    return 0;
}

int del_sem(int sem_id)
{
    union semun sem_union;
    if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)
    {
        perror("Delete semaphore");
        return -1; 
    }
}

int sem_p(int sem_id)
{
    struct sembuf sem_b;
    sem_b.sem_num = 0; /* 表示单个信号量 */
    sem_b.sem_op = -1; /* 表示P操作 */
    sem_b.sem_flg = SEM_UNDO;
    
    if (semop(sem_id, &sem_b, 1) == -1) 
    {
        perror("P operation");
        return -1;
    }
    return 0;
}

int sem_v(int sem_id)
{
    struct sembuf sem_b;
    
    sem_b.sem_num = 0; /* 表示单个信号量 */
    sem_b.sem_op = 1; /* 表示V操作 */	
    sem_b.sem_flg = SEM_UNDO; 
    
    if (semop(sem_id, &sem_b, 1) == -1)
    {
        perror("V operation");
        return -1;
    }
    return 0;
}
```




### 共享内存

进程间采用共享内存的方式进行通信，可以直接读写内存，不需要任何数据的复制，可以说共享内存是一种最为高效的进程间通信方式。由于多个进程共享一段内存，因此也需要如互斥锁、信号量等来实现同步机制。



#### 创建共享内存

shmget()函数用来从内存中获得一段共享内存区域。一个进程运行shmget()函数创建了共享内存后，要获得共享内存的其他程序也需要使用相同的 key 运行shmget()从而获得共享内存即可。

``` c
int shmget(key_t key, int size, int shmflg)
```

`key：` 共享内存的键值，多个进程可以通过它访问同一个共享内存。感觉和上面的信号量key差不多。

`size：` 共享内存区大小。

`shmflg：` 同open()函数的权限位。

返回值：成功：共享内存段标识符；出错：-1。


#### 映射共享内存

shmat()函数将创建的共享内存映射到具体的进程空间中。要共享的进程也需要运行shmat()函数，从而获得共享内存的地址。

``` c
char *shmat(int shmid, const void *shmaddr, int shmflg)
```

`shmid：` 要映射的共享内存段标识符，即shmget()的返回值。

`*shmaddr：` 将共享内存映射到指定地址，若为0则表示系统自动分配地址。

`shmflg：` SHM_RDONLY：共享内存只读；默认0：可读写。

返回值：成功：被映射的段的地址；出错：-1。

#### 撤销共享内存

shmdt()函数用来撤销共享内存的映射操作。

``` c
int shmdt(const void *shmaddr)
```

`*shmaddr：` 被映射的共享内存段地址。


### 消息队列

消息队列就是一些消息的列表，用户可以从消息队列中添加消息和读取消息。可以看出有一些FIFO的特性，但是它可以实现消息的随机查询，比FIFO具有更大的优势。

#### 创建消息队列

msgget()函数用来创建或打开消息队列。

``` c
int msgget(key_t key, int msgflg)
```

`key：` 消息队列键值。同上面的两个key功能。

`msgflg：` 权限标志位。

返回值：消息队列ID；出错：-1。

#### 添加消息

msgsnd()函数添加消息到消息队列中，然后另一个进程通过msgget()打开同样key的消息队列后，就可以从这个队列中读取消息了。

``` c
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)
```

`msqid：` 消息队列ID，即msgget()的返回值。

`*msgp：` 指向消息结构的指针。该消息结构msgbuf通常为：

``` c
struct msgbuf
{
    long msg_type;       //消息类型
    char msg_text[SIZE]; //消息正文
}
```


`msgsz：` 消息正文的字节数。

`msgflg：` IPC_NOWAIT：若消息无法立即发送，函数立即返回；0：阻塞直到发送成功。

返回值：成功0，出错-1。


#### 读取消息

msgrcv()函数用来读取消息。

``` c
int msgrcv(int msqid, void *msgp, size_t msgsz, long int msgtyp, int msgflg)
```

msqid：消息队列ID。

*msgp和msgsz：同msgsnd()函数。


`msgtyp：` 0：接收消息队列中第一个消息；大于0：接收队列中第一个类型为msgtyp的消息；小于0：接收队列中第一个类型值不小于msgtyp绝对值且类型值又最小的消息？（这个感觉矛盾呀）

`msgflg：` MSG_NAERROR：若返回的消息比msgsz字节多，消息截短到msgsz字节；IPC_NOWAIT：若消息队列中没有相应类型的消息可接收，函数立即返回；0：阻塞直到接收到一条相应类型的消息为止。


返回值：成功0，出错-1。


#### 控制消息队列

msgctl()函数用来控制消息队列，可以设定消息队列、从内核中删除消息队列等。

``` c
int msgctl(int msqid, int cmd, struct msqid_ds *buf)
```

`msqid：` 消息队列ID。  
`cmd：` IPC_STAT：读取消息队列的数据结构msqid_ds，将其存储在buf指定的地址中；IPC_SET：设置msqid_ds中的ipc_perm域值（操作权限描述结构），值取自buf参数；IPC_RMID：删除消息队列；  
`*buf：` 描述msqid_ds结构的变量。  
返回值：成功0，出错-1。

除了上述的几种进程方式外，不同进程间还能通过socket套接字的方式进行通信，这将会在其他部分中介绍到。