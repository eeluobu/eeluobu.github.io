---
layout:     post
title:      "Linux设备驱动模型（二）"
subtitle:   "bus设备驱动模型"
date:       2016-05-03
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - linux
    - device
    - driver
---

前面说了字符设备和misc设备模型，是linux设备驱动的基础，几乎很多模型都是基于此构建的。

> 模型隐藏在交互背后，与设备模型直接交互的通常由总线级逻辑和其他内核子系统来处理。其结果是，许多驱动程序的作者可以完全忽略设备模型，并相信设备模型能处理好它所负责的事情。

### kobject和kset

kobject作为一个设备模型的基本结构，被嵌入到好多其他模型结构中。kset可以看成是kobject的集合，在同一个kset集合中，kobject通过其中的`*parent`指向kset中的kobject。

#### kobject结构
上一篇介绍的字符设备描述结构cdev中，就包含kobject，如果有cdev结构得到kobject很简单，一个`->`就行了。但是想反过来，由kobject得到cdev，就需要用到`container_of`这个宏了，这个宏比较常用的是在open这函数中。

``` c
struct kobject *kp;
struct cdev *device = container_of(kp, struct cdev, kobj);
```
`kp`为需要转换的kobject指针，`struct cdev`要转换的类型，`kobj`为cdev结构中的kobj元素。

下面是kobject的结构

``` c
struct kobject {
    const char		*name;
    struct list_head	entry;
    struct kobject		*parent;
    struct kset		*kset;
    struct kobj_type	*ktype;
    struct sysfs_dirent	*sd;
    struct kref		kref;
    unsigned int state_initialized:1;
    unsigned int state_in_sysfs:1;
    unsigned int state_add_uevent_sent:1;
    unsigned int state_remove_uevent_sent:1;
    unsigned int uevent_suppress:1;
};
```
比较常用的，其中`entry`指向kset中下一个kobject，`*parent`指向kset的kobject，`kref`为引用计数，看一下`kobj_type`的结构

``` c
struct kobj_type {
    void (*release)(struct kobject *kobj);
    const struct sysfs_ops *sysfs_ops;
    struct attribute **default_attrs;
    const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);
    const void *(*namespace)(struct kobject *kobj);
};
```
常用的有`release`方法，`**default_attrs`属性列表，用于创建该类型的每一个kobject，`*sysfs_ops`提供了实现这些属性的方法。

**struct attribute**

``` c
struct attribute {
    const char *name;
    mode_t mode;
};
```
name为属性的名字，在`/sys/`下显示。mode通常为`S_IRUGO`读属性，如果可写使用`S_IWUSR`。

**struct sysfs_ops**

``` c
struct sysfs_ops {
    ssize_t	(*show)(struct kobject *, struct attribute *,char *);
    ssize_t	(*store)(struct kobject *,struct attribute *,const char *, size_t);
};
```
当用户空间读取一个属性时，内核会调用`show`方法（通过指向kobject的指针和正确的属性结构），同样写时调用`store`方法。

#### kset结构

``` c
struct kset {
    struct list_head list;
    spinlock_t list_lock;
    struct kobject kobj;
    const struct kset_uevent_ops *uevent_ops;
};
```
其中`*uevent_ops`为热插拔事件。

#### 具体操作
对于这些结构的使用，大多数情况下是注册（register）和注销（unregister）即可。

##### 模块init函数

**kest注册**

``` c
void kset_init(struct kset *kset);
int __must_check kset_register(struct kset *kset);
```
**kobject注册**

``` c
int kobject_init_and_add(struct kobject *kobj,
                         struct kobj_type *ktype,
                         struct kobject *parent,
                         const char *fmt, ...)
         __attribute__((format(printf, 4, 5)));
```
上面的kobject_init_and_add函数是init和add的结合函数，看起来比较复杂，看一个实际使用的例子就一目了然了。

``` c
struct kobject kobj,
struct kobj_type ktype,
kobject_init_and_add(&kobj, &ktype, NULL, "name");
```
name为属性名，创建好后，在`/sys/`下显示为一个目录。

##### 模块exit函数

**kset和kobject的注销**

``` c
void kobject_del(struct kobject *kobj);
void kset_unregister(struct kset *kset);
```

### 总线设备

总线设备的在`/sys/bus/`目录下。

总线是处理器和一个或多个设备之间的通道。在设备模型中，所有的设备都通过总线相连。

#### 总线结构

``` c
struct bus_type {
    const char     *name;
    struct bus_attribute	*bus_attrs;
    struct device_attribute	*dev_attrs;
    struct driver_attribute	*drv_attrs;  
    
    int (*match)(struct device *dev, struct device_driver *drv);
    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
    int (*probe)(struct device *dev);
    int (*remove)(struct device *dev);
    void (*shutdown)(struct device *dev);
    
    int (*suspend)(struct device *dev, pm_message_t state);
    int (*resume)(struct device *dev);

    const struct dev_pm_ops *pm;
    struct subsys_private *p;
};
```
name为总线的类型名称，即bus/目录下的目录名。比较重要的总线方法有`match`，是一个匹配函数，当一个总线上添加新的设备或者驱动时，调用这个函数。来看一下总线属性：

**bus_attribute**

``` c
struct bus_attribute {
    struct attribute    attr;
    ssize_t (*show)(struct bus_type *bus, char *buf);
    ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};
```
其中的struct attribute，show和store在前面都已经介绍过了。


**具体操作**

``` c
int __must_check bus_register(struct bus_type *bus);
void bus_unregister(struct bus_type *bus);
```

#### 设备结构

设备结构`struct device`也是一个很基础的结构，经常被嵌入到一些特定的设备结构中。

``` c
struct device {
    struct device   *parent;
    struct bus_type *bus;
    const char    *init_name;
    void  (*release)(struct device *dev);
    
    struct device_private *p;
    struct kobject kobj;
    struct device_type  *type;
    
    struct mutex    mutex;
    struct device_driver *driver;	
    void     *platform_data;
    struct dev_pm_info  power;
    struct dev_power_domain *pwr_domain;

    u64   *dma_mask;
    u64   coherent_dma_mask;

    struct device_dma_parameters *dma_parms;

    struct list_head  dma_pools;

    struct dma_coherent_mem *dma_mem; 
    struct dev_archdata archdata;

    struct device_node  *of_node; 

    dev_t    devt;	

    spinlock_t   devres_lock;
    struct list_head  devres_head;

    struct klist_node knode_class;
    struct class     *class;
    const struct attribute_group **groups;
};
```
突然发现这个量有点大，ldd3中说在注册device结构之前，至少要设置`parent`、`bus_id`、`bus`和`release`成员。在上面的代码中找了好几遍，其他三个都找到了，就是没找到`bus_id`。上网查了一下才发现，现在的内核版本里已经改成了`*init_name`，同时可以通过dev_set_name()函数来设置名称。

**attribute_group**

``` c
struct attribute_group {
    const char  *name;
    mode_t      (*is_visible)(struct kobject *, struct attribute *, int);
    struct attribute	**attrs;
};
```

**device_attribute**

``` c
struct device_attribute {
    struct attribute  attr;
    ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf);
    ssize_t (*store)(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
};
```
感觉和bus_attribute大同小异。

**具体操作**

``` c
int __must_check device_register(struct device *dev);
void device_unregister(struct device *dev);
```

#### 设备驱动结构

设备驱动结构`struct device_driver`和设备结构struct device差不多，经常被嵌入到一些特定的驱动结构中。

``` c
struct device_driver {
    const char    *name;
    struct bus_type  *bus;

    //设备驱动方法
    int (*probe) (struct device *dev);
    int (*remove) (struct device *dev);
    void (*shutdown) (struct device *dev);
    int (*suspend) (struct device *dev, pm_message_t state);
    int (*resume) (struct device *dev);
    
    const struct attribute_group **groups;
    struct module  *owner;
    const char     *mod_name;	
    bool suppress_bind_attrs;	
    const struct of_device_id	*of_match_table;
    const struct dev_pm_ops *pm;
    struct driver_private *p;
};
```
`*name`为驱动名，`*bus`为驱动所属的总线。

Linux 2.6.39中的内核和ldd3中的介绍的内核，在这一块还是有很大区别的。比如说在struct device和struct device_driver中又增加了好多新的元素，也是搞的我云里雾里的，今后还要多读读新内核才是。

**具体操作**

``` c
int __must_check driver_register(struct device_driver *drv);
void driver_unregister(struct device_driver *drv);
```

以上就是总线设备的内容了，platform设备准备另开一篇来写。继续努力！

