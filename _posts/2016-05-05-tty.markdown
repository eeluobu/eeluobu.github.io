---
layout:     post
title:      "TTY驱动程序"
subtitle:   "tty和uart框架下的串口驱动程序"
date:       2016-05-05
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - linux
    - 串口
    - tty
    - uart
---

### TTY框架

有3种不同类型 tty 驱动：控制台，串口，和 pty 。控制台和 pty 驱动在内核中已经被编写好了，唯一需要编写的就是串口类型的驱动。

#### 工作流程

下面是用户程序和tty设备之间进行通信的流程图

![img](/img/post/tty.jpg)

**tty core**从用户获取将要发送给tty设备的数据，传递数据到**tty line discipline**（线路规程）驱动，然后线路规程驱动传递数据到**tty driver**。最后tty driver将数据格式转换后，发送给硬件。

从tty 硬件收到的数据向上传输通过tty driver，进入到tty line discipline驱动，再进入到tty core，然后被用户获取。

有时tty core和tty driver之间也可以不通过tty line discipline（线路规程）驱动进行通信。另外线路规程对数据格式的转化通常可以通过一些协议来实现，比如PPP或者Bluetooth等。

#### uart和tty

最开始的时候，老搞不清楚uart和tty的区别，以为uart驱动就是tty驱动。其实不是这样的，tty驱动程序是通用的一个tty设备程序框架，tty设备包含uart设备。也就是说，tty设备的驱动框架可以用来驱动uart设备，但是在Linux程序中，uart设备的驱动程序被开发者单独写出来了，不过uart的程序框架也是在tty基础上。

下面介绍的tty设备驱动程序是通用的，也就是说在不同的平台上一般是可以用的，移植的话无非就是底层的寄存器需要更改一下。


### TTY结构


#### tty_driver

tty_driver结构用来向tty core注册一个 tty 驱动程序。

``` c
struct tty_driver {
    int	magic;        /* magic number for this structure */
    struct kref kref; /* Reference management */
    struct cdev cdev;
    struct module *owner;
    const char *driver_name;
    const char *name;
    int	name_base;   /* offset of printed name */
    int	major;       /* major device number */
    int	minor_start; /* start of minor device number */
    int	minor_num;   /* number of *possible* devices */
    int	num;         /* number of devices allocated */
    short type;      /* type of tty driver */
    short subtype;   /* subtype of tty driver */
    struct ktermios init_termios; /* Initial termios */
    int	flags;       /* tty driver flags */
    struct proc_dir_entry *proc_entry; /* /proc fs entry */
    struct tty_driver *other; /* only used for the PTY driver */
    /*
     * Pointer to the tty data structures
     */
    struct tty_struct **ttys;
    struct ktermios **termios;
    struct ktermios **termios_locked;
    void *driver_state;
    /*
     * Driver methods
     */
    const struct tty_operations *ops;
    struct list_head tty_drivers;
};

```
其中`init_termios`为ktermios结构。

**struct ktermios**

``` c
struct termios {
    tcflag_t c_iflag;  /* input mode flags */
    tcflag_t c_oflag;  /* output mode flags */
    tcflag_t c_cflag;  /* control mode flags */
    tcflag_t c_lflag;  /* local mode flags */
    cc_t c_line;       /* line discipline */
    cc_t c_cc[NCCS];   /* control characters */
};
```

#### tty_operations

tty_operations结构包含所有的回调函数，这些函数可以被tty driver设置和被tty core调用。所有包含在这个结构中的的函数指针也在tty_driver结构中，但是会很快被只有一个这个结构的实例替代。

``` c
struct tty_operations {
    struct tty_struct * (*lookup)(struct tty_driver *driver, struct inode *inode, int idx);
    int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
    void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
    int  (*open)(struct tty_struct * tty, struct file * filp);
    void (*close)(struct tty_struct * tty, struct file * filp);
    void (*shutdown)(struct tty_struct *tty);
    void (*cleanup)(struct tty_struct *tty);
    int  (*write)(struct tty_struct * tty, const unsigned char *buf, int count);
    int  (*put_char)(struct tty_struct *tty, unsigned char ch);
    void (*flush_chars)(struct tty_struct *tty);
    int  (*write_room)(struct tty_struct *tty);
    int  (*chars_in_buffer)(struct tty_struct *tty);
    int  (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
    long (*compat_ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
    void (*set_termios)(struct tty_struct *tty, struct ktermios * old);
    void (*throttle)(struct tty_struct * tty);
    void (*unthrottle)(struct tty_struct * tty);
    void (*stop)(struct tty_struct *tty);
    void (*start)(struct tty_struct *tty);
    void (*hangup)(struct tty_struct *tty);
    int  (*break_ctl)(struct tty_struct *tty, int state);
    void (*flush_buffer)(struct tty_struct *tty);
    void (*set_ldisc)(struct tty_struct *tty);
    void (*wait_until_sent)(struct tty_struct *tty, int timeout);
    void (*send_xchar)(struct tty_struct *tty, char ch);
    int  (*tiocmget)(struct tty_struct *tty);
    int  (*tiocmset)(struct tty_struct *tty, unsigned int set, unsigned int clear);
    int  (*resize)(struct tty_struct *tty, struct winsize *ws);
    int  (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);
    int  (*get_icount)(struct tty_struct *tty, struct serial_icounter_struct *icount);
    
    const struct file_operations *proc_fops;
};
```
上面的函数比较多，一般实现open 、close 、write 、write_room 、set_termios 、tiocmget 、tiocmset等。

`write_room`：用来检测缓冲区的剩余空间；

`set_termios`：当设备的termios设置发生改变时，该函数被tty_core调用;

`tiocmget`：获得特定tty设备的当前线路设置；

`tiocmset`：为特定的tty设备设置当前线路。



#### tty_struct

tty core使用tty_struct保存当前特定tty端口的状态，除了少数的例外，改结构中的所有成员都只能被tty core所使用。

``` c
struct tty_struct {
    int	magic;
    struct kref kref;
    struct device *dev;
    struct tty_driver *driver;
    const struct tty_operations *ops;
    int index;
    
    /* Protects ldisc changes: Lock tty not pty */
    struct mutex ldisc_mutex;
    struct tty_ldisc *ldisc;
    
    struct mutex termios_mutex;
    spinlock_t ctrl_lock;
    /* Termios values are protected by the termios mutex */
    struct ktermios *termios, *termios_locked;
    struct termiox *termiox;	/* May be NULL for unsupported */
    char name[64];
    struct pid *pgrp;		/* Protected by ctrl lock */
    struct pid *session;
    unsigned long flags;
    int count;
    struct winsize winsize;		/* termios mutex */
    unsigned char stopped:1, hw_stopped:1, flow_stopped:1, packet:1;
    unsigned char low_latency:1, warned:1;
    unsigned char ctrl_status;	/* ctrl_lock */
    unsigned int receive_room;	/* Bytes free for queue */
    
    struct tty_struct *link;
    struct fasync_struct *fasync;
    struct tty_bufhead buf;		/* Locked internally */
    int alt_speed;		/* For magic substitution of 38400 bps */
    wait_queue_head_t write_wait;
    wait_queue_head_t read_wait;
    struct work_struct hangup_work;
    void *disc_data;
    void *driver_data;
    struct list_head tty_files;
    
#define N_TTY_BUF_SIZE 4096

   /*
    * The following is data for the N_TTY line discipline.  For
    * historical reasons, this is included in the tty structure.
    * Mostly locked by the BKL.
    */
    unsigned int column;
    unsigned char lnext:1, erasing:1, raw:1, real_raw:1, icanon:1;
    unsigned char closing:1;
    unsigned char echo_overrun:1;
    unsigned short minimum_to_wake;
    unsigned long overrun_time;
    int num_overrun;
    unsigned long process_char_map[256/(8*sizeof(unsigned long))];
    char *read_buf;
    int read_head;
    int read_tail;
    int read_cnt;
    unsigned long read_flags[N_TTY_BUF_SIZE/(8*sizeof(unsigned long))];
    unsigned char *echo_buf;
    unsigned int echo_pos;
    unsigned int echo_cnt;
    int canon_data;
    unsigned long canon_head;
    unsigned int canon_column;
    struct mutex atomic_read_lock;
    struct mutex atomic_write_lock;
    struct mutex output_lock;
    struct mutex echo_lock;
    unsigned char *write_buf;
    int write_cnt;
    spinlock_t read_lock;
    /* If the tty has a pending do_SAK, queue it here - akpm */
    struct work_struct SAK_work;
    struct tty_port *port;
};
```


### 操作函数

#### tty注册

**分配tty驱动程序**

``` c
tiny_tty_driver = alloc_tty_driver(TINY_TTY_MINORS);
```
TINY_TTY_MINORS为tty设备的数量。

**定义操作函数**

``` c
static struct tty_operstions serial_ops = {
    .open = demo_open,
    .close = demo_close,
    .write = demo_write,
    .write_room = demo_write_room,
    .set_termios = demo_set_terimos,
};
```

**初始化tty驱动程序**

``` c
tiny_tty_driver->owner = THIS_MODULE;
tiny_tty_driver->driver_name = "tiny_tty";
tiny_tty_driver->name = "ttty";
/*省略一些tiny_tty_driver的初始化*/

/*.....*/

tty_set_operations(tiny_tty_driver, &serial_ops);
```

**注册tty驱动程序**

``` C
tty_register_driver(tiny_tty_driver);
```

**注册tty设备**

``` c
for (i = 0; i < TINY_TTY_MINORS; i++)
    tty_register_device(tiny_tty_driver, i, NULL);
```
第二个参数`i`是tty设备的序号。

tty设备和驱动注册好之后，就可在应用程序中**open**，然后使用相关函数配置好参数后，就可以使用**read**和**write**函数进行读写。

#### tty注销

**注销tty设备和驱动程序**

``` c
for (i = 0; i < TINY_TTY_MINORS; i++)
    tty_unregister_device(tiny_tty_driver, i);
tty_unregister_driver(tiny_tty_driver);
```

### UART框架

关于驱动uart设备，前面讲的是一种使用tty驱动框架的方法，另一种是使用Uart驱动框架加上tty驱动框架混合驱动。


### UART结构

uart驱动程序围绕三个关键的数据结构展开，分别是：`uart_driver`、`uart_port`、`uart_ops`。

#### uart_driver

struct uart_driver是Uart相关的驱动程序的特定结构。

``` c
struct uart_driver {
    struct module *owner;
    const char    *driver_name;
    const char    *dev_name;
    int   major;
    int   minor;
    int   nr;
    struct console *cons;
    /*
     * these are private; the low level driver should not
     * touch these; they should be initialised to NULL
     */   
    struct uart_state	*state;
    struct tty_driver	*tty_driver;
};
```

#### uart_port

struct uart_port结构用来对Uart的端口进行初始化和配置。

``` c
struct uart_port {
    spinlock_t lock;
    unsigned long iobase;  /*输入输出[bwl] */
    unsigned char __iomem *membase;  /* 读写[bwl] */
    unsigned int  (*serial_in)(struct uart_port *, int);
    void (*serial_out)(struct uart_port *, int, int);
    void (*set_termios)(struct uart_port *,struct ktermios *new,struct ktermios *old);
    int  (*handle_irq)(struct uart_port *);
    void (*pm)(struct uart_port *, unsigned int state, unsigned int old);
    unsigned int  irq;       /* 中断号 */
    unsigned long irqflags;  /* 中断标志位 */
    unsigned int  uartclk;   /*uart基础时钟 */
    unsigned int  fifosize;  /* 发送fifo深度 */
    unsigned char x_char;    /* xon/xoff char */
    unsigned char regshift;  /* reg offset shift */
    unsigned char iotype;    /* io通道类型 */

/*省略了一些函数*/
/*.......*/
/*.......*/


};
```

#### uart_ops

struct uart_ops结构体是每一个Uart驱动程序必须支持的物理硬件上可以完成的入口函数的集合。

``` c
struct uart_ops {
    unsigned int (*tx_empty)(struct uart_port *);
    void     (*set_mctrl)(struct uart_port *, unsigned int mctrl);
    unsigned int (*get_mctrl)(struct uart_port *);
    void (*stop_tx)(struct uart_port *);
    void (*start_tx)(struct uart_port *);
    void (*send_xchar)(struct uart_port *, char ch);
    void (*stop_rx)(struct uart_port *);
    void (*enable_ms)(struct uart_port *);
    void (*break_ctl)(struct uart_port *, int ctl);
    int  (*startup)(struct uart_port *);
    void (*shutdown)(struct uart_port *);
    void (*flush_buffer)(struct uart_port *);
    void (*set_termios)(struct uart_port *, struct ktermios *new, struct ktermios *old);
    void (*set_ldisc)(struct uart_port *, int new);
    void (*pm)(struct uart_port *, unsigned int state, unsigned int oldstate);
    int  (*set_wake)(struct uart_port *, unsigned int state);
/*
* Return a string describing the type of the port
*/
    const char *(*type)(struct uart_port *);
/*
* Release IO and memory resources used by the port.
* This includes iounmap if necessary.
*/
    void (*release_port)(struct uart_port *);
/*
* Request IO and memory resources used by the port.
* This includes iomapping the port if necessary.
*/
    int  (*request_port)(struct uart_port *);
    void (*config_port)(struct uart_port *, int);
    int  (*verify_port)(struct uart_port *, struct serial_struct *);
    int  (*ioctl)(struct uart_port *, unsigned int, unsigned long);
};
```

### 操作函数

基本的结构体介绍完了，然后就是操作了，和使用tty结构驱动一样，首先是注册，然后是添加，然后是使用，最后是移除并释放资源。

#### 注册


使用Uart层驱动注册一个Uart设备。

``` c
int uart_register_driver(struct uart_driver *drv);
```
注册完之后，需要调用uart_add_one_port函数，添加一个已定义的端口结构。

``` c
int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport);
```
`*drv`：指向该端口的低等级驱动的uart的指针；

`*uport`：uart要使用的端口结构。


#### 功能函数

注册好了就可以通过功能函数发送和读写数据了。

**发送功能函数**

``` c
static int uart_write(struct tty_struct *tty, const unsigned char *buf, int count);
```
该函数用来往`*buf`里面写字符串，写完后将字符串发送出去。

``` c
static int uart_put_char(struct tty_struct *tty, unsigned char ch);
```
该函数用来发送单个字符。

**接收函数**

这里要注意，接收不是uart_read，uart框架中包括前面讲的tty都是没有read函数。因为发送数据是用户主动地，而接收（当用户调用read()函数时）则是读一片缓冲区中已经放好的数据。

``` c
void tty_flip_buffer_push(struct tty_struct *tty);
```
tty核心将数据放在上面的函数中的缓冲数据上，直到被用户请求。因为tty核心提供了缓冲逻辑，因此每个tty驱动并非一定要实现他自身的缓冲逻辑。

对于buffer，有以下几个常用的基本函数。

``` c
static struct tty_buffer *tty_buffer_alloc(struct tty_struct *tty, size_t size);
/* 申请一个size大小的buffer */

static void tty_buffer_free(struct tty_struct *tty, struct tty_buffer *b);
/* 释放一块指定地址的buffer */

void tty_buffer_flush(struct tty_struct *tty);
/* 用于刷新buffer */

void tty_buffer_init(struct tty_struct *tty);
/* 用于buffer初始化 */

static inline int tty_insert_flip_char(struct tty_struct *tty, unsigned char ch, char flag);
/* 用于向buffer中插入单个字符 */

static inline int tty_insert_flip_string(struct tty_struct *tty, const unsigned char *chars, size_t size);
/* 用于向buffer中插入一个字符串 */
```

#### 注销

移除函数为

``` c
int uart_remove_one_port(struct uart_driver *drv, struct uart_port *uport);
```
注销函数为

``` c
void uart_unregister_driver(struct uart_driver *drv);
```