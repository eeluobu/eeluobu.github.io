---
layout:     post
title:      "Linux设备驱动（一）"
subtitle:   "设备驱动模型"
date:       2016-05-02
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - linux
    - device
    - driver
---

最开始接触这些驱动模型的时候，总感觉它们是相互独立的，直到看了具体的例程，才发现它们相互联系，而且互相包含，在程序中需要配合使用才能发挥效率。

> 众里寻他千百度，蓦然回首，那人却在，灯火阑珊处。

### 字符设备
linux系统将设备分成三种基本类型，分别为：字符设备、块设备、网络设备。

LDD3中这样描述字符设备：

> 字符（char）设备是一种可以当作一个字节流来存取的设备（如同一个文件），一个字符驱动负责实现这种行为。这样的驱动常常至少实现 open，close，read和write系统调用。

#### 字符设备文件

应用程序通过文件名访问字符设备文件，字符设备文件和设备驱动程序通过主设备号相关联。

应用程序(`文件名`) ---> 字符设备文件(`主设备号`) ---> 驱动程序

字符设备文件可以用`mknod`来创建，同时需要指定主设备和次设备号

``` bash
mknod /dev/设备名 c 主设备号 次设备号
```
手动创建之前还要知道主次设备号，通过下面的`cat`命令找到设备名对应的设备号

``` bash
cat /proc/devices
```
还可以在程序中自动创建字符设备文件，先在内核初始化函数中声明一个`class`，前面还带struct和C++的有区别，并不是真正的class。

``` c
struct class *myclass;
...
myclass = class_create(THIS_MODULE,"test_class");
device_create(myclass, NULL, MKDEV(major,0), NULL, "设备名");   
```

函数`class_create`在/sys/class/test_class目录下创建设备，在此目录下有个`"设备名"`文件，这个文件里面就有设备的主次设备号（这里感觉像`/proc/devices`文件夹）。在`device_create`函数创建设备文件时，就能直接找到啦。

#### 操作函数集

这是一个很重要的结构，没记错的话后面的设备驱动好像每一个都包含有这个叫`file_operations`的结构体。

下面是LDD3中的例子，scull_fops在定义时只是用了其中的一部分

``` c
struct file_operations fops = { 
    .owner = THIS_MODULE, 
    .llseek = scull_llseek, 
    .read = scull_read, 
    .write = scull_write, 
    .ioctl = scull_ioctl, 
    .open = scull_open, 
    .release = scull_release, 
};
```
> 这个声明使用标准的C的标记式结构初始化语法。这个语法是值得采用的，因为它使驱动程序在结构定义的改变发生变化时更具可移植性，并且使代码更加紧凑和易读。

**注意** 在Linux 2.6.36之后的版本中，用的都是`unlocked_ioctl`，而不是上面的`ioctl`。

还有两个伴随着文件经常出现的结构，不过不需要我们亲自去调用它。

**struct file**

每一个打开的文件（open）中都关联这个结构，包含读写指针（loff_t f_pos;），操作文件集（struct file_operations *f_op;）等。

**struct inode**

> inode结构由内核在内部用来表示文件，因此它和file结构不同，后者表示打开的文件描述符。对单个文件，可能有多个表示打开的文件描述符的file结构，但是它们都指向`单个`inode结构。

包含设备号（dev_t i_rdev;），字符描述结构（struct cdev *i_cdev;）等。

#### 字符设备描述结构

很多驱动都有自己的设备结构，但他们都包含有`struct cdev`结构。主要的参数有

``` c
file_operations *ops; //操作函数集
dev_t dev;            //设备号
uint count;           //设备数
```
设备号结构`dev_t`包括主设备号、次设备号。通过MAJOR(dev)获得主设备号，MANOR(dev)获得次设备号，逆过程为MKDEV(主,次)。

动态分配

``` c
struct cdev *my_cdev = cdev_alloc();
my_cdev->ops = &my_fops;
```
静态分配

``` c
struct cdev my_cdev;
```

#### 具体操作
接下来就是在一个字符设备驱动程序中，要具体操作的过程了，也可以说成是程序流程。


##### 模块init函数
**申请设备号**

有动态静态两种方式，静态的

``` c
dev_t dev;
register_chrdev_region(dev, 设备个数, "设备名");
```
以下为动态的申请

``` c
alloc_chrdev_region(&dev, 通常为0, 设备个数, "设备名");
```
设备号`dev`在这个函数里是`输出`的参数。动态的好处是，当设备号冲突时，会自动分配，而不会像静态的那样分配失败。

**初始化cdev结构**

``` c
cdev_init(&my_cdev, &my_fops);
```

**注册字符设备**

``` c
cdev_add(&my_cdev, MKDEV(major, 0), 设备数);
```

##### 模块exit函数

**注销设备**

``` c
cdev_del(&my_cdev);
```
**释放设备号**

设备号很宝贵，只有255个（可能还没有这么多），用完要及时返还给系统。

``` c
unregister_chrdev_region(MKDEV(major, 0), 分配的设备数目);
```

自此字符设备驱动就算复习巩固完了。

---

### 混杂设备

个人感觉miscdevice在写驱动程序时是一个很好的模型，比普通的字符设备使用更方便，不知道是内核版本还是什么原因，LDD3中好像并没有介绍这个驱动模型。

#### 混杂设备结构

miscdevice在内核中的声明如下

``` c
struct miscdevice {
    int minor;
    const char *name;
    const struct file_operations *fops;
    struct list_head list;
    struct device *parent;
    struct device *this_device;
    const char *nodename;
    mode_t mode;
};
```
常用的参数有，minor次设备号（以为混杂设备的主设备号固定为`10`），name设备名，*fops函数操作集。

#### 具体操作

由于不需要申请设备号，相应的也简化了操作。

##### 模块init函数

在初始化miscdevice时，通常可以这样

``` c
static struct miscdevice my_dev = {
    .minor = 次设备号;
    .name = "设备名";
    .fops = &my_ops;
};
```
注册misc设备

``` c
misc_register(&my_dev);
```

##### 模块exit函数

注销misc设备

``` c
misc_deregister(&my_dev);
```

怎么样，和cdev形式的字符设备相比，是不是很方便！