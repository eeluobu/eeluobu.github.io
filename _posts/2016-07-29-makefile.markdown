---
layout:     post
title:      "常用Makefile语法"
subtitle:   "Makefile文件中常用的变量、参数、函数等使用"
date:       2016-07-29
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - linux
    - Makefile
---

Makefile 的基本格式如下，目标文件后 ： 加上依赖文件，下一行是命令，开头要用[TAB]键。

目标 : 依赖  
[TAB] 命令

#### 变量


##### 自动变量

makefile中一些常用的自动变量：  
   
$@ 目标文件（完整名）  
$* 目标文件（不包含拓展名）  
   
$^ 所有依赖文件（不包含重复）   
$? 所有依赖文件（依赖文件晚于目标）  
$+ 所有依赖文件（可能重复）  
$< 第一个依赖文件  
  
$% 归档成员名称  

 

##### 环境变量

makefile中常用的环境变量：

`CC ` c编译器名称（默认cc）  
`CXX` c++编译器名称（默认g++）  
`AS ` 汇编器（as）  
`AR ` 库管理器（ar）  
`LD ` 链接器（ld）  


`CFLAGS` 编译器选项：指定头文件路径（-I 大写i）  
`LDFLAGS` 链接选项：库文件路径（-L）、库文件（-l 小写l）    
`LIBS `   链接选项：指定库文件（-l 小写l）


为了便于理解，下面是 gcc 编译器的一些参数：

-o 输出指定文件名  
-E 预处理，产生 .i 文件  
-S 编译产生汇编 .s 文件  
-c 编译、汇编，不链接产生 .o 二进制目标文件  

-I 大写i，指定头文件路径  
-L 大写l，链接指定库文件路径  
-l 小写l，链接指定库文件  

代码编译流程：  
*源代码.c* --> `预编译` --> *.i文件* --> `编译器` --> *汇编代码.s* --> `汇编器` --> *目标代码.o* --> `链接器` --> *可执行程序*



#### 函数

**subst** 替换

``` bash
$(subst $(a),$(b),$(c))   #把c中的a替换成b
```

**patsubst** 替换  

``` bash
src := $(patsubst %.c,%.o,wildcard *.c)  #将.c替换成.o
```

**wildcard** 使通配符有效，如上把当前目录各个文件展开为空格分开


上面的命令还能写成

``` bash
src := $(shell ls *.c)
out := $(patsubst %.c,%.o,$(src))  
#等价于 
out := $(src:.c=.o) 
#等价于 
out := $(src:%.c=%.o)
```

**strip** 去空格  

``` bash
$(strip $(a))  #去掉a串中的空格
```

**origin** 来源  

``` bash
$(origin V)   
#V的来源，如环境、非环境（命令行、文件）"environment""command line"
```

``` bash
#如果V来自命令行，执行语句1
ifdef V
  ifeq ("$(origin V)","command line")
    语句1
  endif
endif
```


(**shell** bash命令)  返回执行结果  

``` bash
file := $(shell cat foo)  
#将foo文件内容写到file中
```

#### 条件语句

1、ifeq  
ifeq ( arg1, arg2 )  
command  
两个参数相同为真，执行command

2、ifneq  
ifneq ( arg1, arg2 )  
command  
两个参数不同相同为真，执行command

3、ifdef  
ifdef 变量  
如果变量不为空，为真

4、ifndef  
ifndef 变量  
如果变量为空，为真

#### 等号赋值

`= ` 赋值（在文件全部展开后赋值，以最后一个为准）  
`:=` 覆盖之前的值（赋给当前变量的值）  
`?=` 如果之前没有赋值，就赋值  
`+=` 添加赋值  

#### 特殊符号

`@ ` 不打印出命令，在make时会打印出Makefile中所有的命令  
`%.c` 通配符（所有.c文件） 


#### 其他

变量的传递：

export:  传递变量到子目录  
unexport:  不传递

.PHONY：

.PHONY 伪目标  
防止有文件名和目标同名


.so为动态库，.a 为静态库。




#### 编译内核模块

不管是linux内核移植，还是自己编写一个内核驱动程序，都需要编译生成内核模块 .ko 文件，直接使用 make modules 命令要很多参数配置，通常都会采用 Makefile 文件。下面是用 Makefile 文件生成一个内核模块的例子。

``` bash
ifneq ($(KERNELRELEASE),)

obj-m := test.o

else

PWD := $(shell pwd)
KDIR := /home/linux-3.14   #linux内核源码目录

all:
	make -C $(KDIR) M=$(PWD) modules ARCH=arm CROSS_COMPILE=arm-linux-
#-C表示切换到内核目录，M=表示生成的模块.ko文件放在当前目录下
#后面为配置的编译工具
clean:
	rm -f *.ko *.o *.mod.o *.mod.c *.symvers  modul*

endif
```