---
layout:     post
title:      "一个并发网络服务实现"
subtitle:   "基于多进程和socket编程"
date:       2016-05-15
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - 多进程
    - socket
    - 守护进程
---

这是一个简单的网络并发服务器实现，能过处理多个客户端的请求。另外，服务器端使用守护进程在后台运行。首先需要运行服务端程序，并在入口处配置服务器ip和端口号。然后运行客户端程序，配置同样的ip和端口号，在终端里输入信息，服务器接收到后会反馈发送回一个相同的信息。

### 服务器端


#### 守护进程


创建守护进程，当运行客户端程序的终端关闭时，依然能够提供来自客服端的服务请求。

``` c
    pid_t pid0;
    int i;
    
    if ((pid0 = fork()) < 0)
    {
        perror("fail to fork in first");
        exit(-1);
    }
    else if (pid0 > 0)
    {
        exit(0);
    }
    
    setsid();
    chdir("/");
    umask(0);
    for(i = 0; i < getdtablesize(); i++)
    {
        close(i);
    }
    
```


#### 建立网络服务


``` c
    int listenfd, connfd;
    char buf[N];
    struct sockaddr_in myaddr;
    pid_t pid;
    
    if (argc < 3)
    {
        printf("Usage : %s <serv_ip> <serv_port>\n", argv[0]);
        exit(-1);
    }
    
    if ((listenfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("fail to socket");
        exit(-1);
    }
    
    bzero(&myaddr, sizeof(myaddr));
    myaddr.sin_family = PF_INET;
    myaddr.sin_port = htons(atoi(argv[2]));
    myaddr.sin_addr.s_addr = inet_addr(argv[1]);
    
    if (bind(listenfd, (SA *)&myaddr, sizeof(myaddr)) < 0)
    {
        perror("fail to bind");
        exit(-1);
    }
    
    listen(listenfd, 5);
    
    
```

#### 多进程处理

``` c
    signal(SIGCHLD, SIG_IGN);
    while ( 1 )
    {
        if ((connfd = accept(listenfd, NULL, NULL)) < 0)
        {
            perror("fail to accept");
            exit(-1);
        }
        if ((pid = fork()) < 0)
        {
            perror("fail to fork");
            exit(-1);
        }
        else if (pid == 0)
        {
            while (recv(connfd, buf, N, 0) >0)
            {
                //printf("receive from client : %s", buf);
                send(connfd, buf, N, 0);
            }
            exit(0);
        }
        else
        {
            close(connfd);
        }
    }
```


#### 源程序

``` c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define N 64

typedef struct sockaddr SA;

int main(int argc, char *argv[])
{
    pid_t pid0;
    int i;
    
    if ((pid0 = fork()) < 0)
    {
        perror("fail to fork in first");
        exit(-1);
    }
    else if (pid0 > 0)
    {
        exit(0);
    }
    
    setsid();
    chdir("/");
    umask(0);
    for(i = 0; i < getdtablesize(); i++)
    {
        close(i);
    }
    
    //守护进程
    
    int listenfd, connfd;
    char buf[N];
    struct sockaddr_in myaddr;
    pid_t pid;
    
    if (argc < 3)
    {
        printf("Usage : %s <serv_ip> <serv_port>\n", argv[0]);
        exit(-1);
    }
    
    if ((listenfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("fail to socket");
        exit(-1);
    }
    
    bzero(&myaddr, sizeof(myaddr));
    myaddr.sin_family = PF_INET;
    myaddr.sin_port = htons(atoi(argv[2]));
    myaddr.sin_addr.s_addr = inet_addr(argv[1]);
    
    if (bind(listenfd, (SA *)&myaddr, sizeof(myaddr)) < 0)
    {
        perror("fail to bind");
        exit(-1);
    }
    
    listen(listenfd, 5);
    
    signal(SIGCHLD, SIG_IGN);
    while ( 1 )
    {
        if ((connfd = accept(listenfd, NULL, NULL)) < 0)
        {
            perror("fail to accept");
            exit(-1);
        }
        if ((pid = fork()) < 0)
        {
            perror("fail to fork");
            exit(-1);
        }
        else if (pid == 0)
        {
            while (recv(connfd, buf, N, 0) >0)
            {
                //printf("receive from client : %s", buf);
                send(connfd, buf, N, 0);
            }
            exit(0);
        }
        else
        {
            close(connfd);
        }
    }
    return 0;
}
```



### 客户端

#### 建立网络连接

``` c
    int sockfd;
    char buf[N];
    struct sockaddr_in servaddr;
    
    if (argc < 3)
    {
        printf("Usage : %s <serv_ip> <serv_port>\n", argv[0]);
        exit(-1);
    }
    
    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("fail to socket");
        exit(-1);
    }
    
    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = PF_INET;
    servaddr.sin_port = htons(atoi(argv[2]));
    servaddr.sin_addr.s_addr = inet_addr(argv[1]);
    
    if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) < 0)
    {
        perror("fail to connect");
        exit(-1);
    }
```



#### 发送和接收

``` c
    while ( 1 )
    {
        printf("client > ");
        fgets(buf, N, stdin);
        if (strncmp(buf, "quit\n", 5) == 0) 
            break;
        send(sockfd, buf, N, 0);
        bzero(buf, N);
        recv(sockfd, buf, N, 0);
        printf("recv from server : %s", buf);
    }
    close(sockfd);
```


#### 源程序

``` c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define N 64

typedef struct sockaddr SA;

int main(int argc, char *argv[])
{
    int sockfd;
    char buf[N];
    struct sockaddr_in servaddr;
    
    if (argc < 3)
    {
        printf("Usage : %s <serv_ip> <serv_port>\n", argv[0]);
        exit(-1);
    }
    
    if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("fail to socket");
        exit(-1);
    }
    
    bzero(&servaddr, sizeof(servaddr));
    servaddr.sin_family = PF_INET;
    servaddr.sin_port = htons(atoi(argv[2]));
    servaddr.sin_addr.s_addr = inet_addr(argv[1]);
    
    if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) < 0)
    {
        perror("fail to connect");
        exit(-1);
    }
    
    while ( 1 )
    {
        printf("client > ");
        fgets(buf, N, stdin);
        if (strncmp(buf, "quit\n", 5) == 0) 
            break;
        send(sockfd, buf, N, 0);
        bzero(buf, N);
        recv(sockfd, buf, N, 0);
        printf("recv from server : %s", buf);
    }
    close(sockfd);
    
    return 0;
}
```
