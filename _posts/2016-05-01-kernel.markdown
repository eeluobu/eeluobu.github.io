---
layout:     post
title:      "Linux内核移植"
subtitle:   "基于Linux2.6.39"
date:       2016-05-01
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true

tags:
    - linux
    - 嵌入式
    - kernel
    - 移植
---

在进行Linux内核模块开发，即设备驱动的开发之前，最重要的就是要在自己的开发板上移植linux kernel。我用的是S3C6410的开发板，其他型号板子和芯片的移植应该大同小异。

### 环境搭建

#### 安装交叉编译工具

``` bash
tar -zxvf arm-linux-gcc.tar.gz -C /
```
交叉编译文件为arm-linux-gcc.tar.gz，`-C`指定解压位置。

#### 添加环境变量

如果只是添加到当前用户环境，就在这个文件`/~/.bashrc`中添加，`~`表示工作目录，普通用户为`/home`，root用户为`/root`；

如果要添加到全局环境（对所有用户生效），需要在`/etc/profile`中添加，要立即生效还需要运行 source /etc/profile 命令，否则只能在下次重新进入此用户时生效。

``` bash
export PATH=$PATH:/usr/local/arm/4.3.2/bin
```
其中`:`表示并列关系，比如上面也可以写成

``` bash
export PATH=/usr/local/arm/4.3.2/bin:$PATH
```

### 编译u-boot
把通用的uboot移植到特定的开发板上还是比较麻烦的一件事，等有时间了还需要仔细的研究一下，下面用的是别人已经改写好的uboot，直接进行编译了。

``` bash
make clean
make 6410_config   #运行6410配置
make CROSS_COMPILE=arm-linux 
cp mkimage /bin
```

### 编译内核

#### Kconfig文件

在编译内核之前了解一下Kconfig文件，配置好后保存到`.config`中，Makefile编译时调用。

其中一个config的大体结构为

``` bash
menu "菜单名"
config 模块
    bool:布尔类型/tristate:三态(M内核、Y模块、N不编译)  "选项名"
    depends on或requires  模块
    default y/n
endmenu
```

#### X86

编译在x86上运行的内核

``` bash
make clean
make menuconfig
make bzImage 
```
成功后在终端显示

> Kernel: arch/x86/boot/bzImage is ready  (#1)

表示在此目录下生成bzImage文件。

#### ARM

编译在ARM上运行的内核

``` bash
make clean
make menuconfig ARCH=arm
make uImage ARCH=arm CROSS_COMPILE=arm-linux-
```

如果要内核nfs启动，在运行make menuconfig之前需要把`.config`文件配置成支持nfs启动，添加

> CONFIG_CMDLINE="root=/dev/nfs nfsroot=192.168.0.1:/nfsroot ip=192.168.0.2 rw console=ttySAC0 mem=64M"

其中`root=/dev/nfs`表示nfs方式启动，`192.168.0.1`为nfs服务器ip，`192.168.0.2`为开发板ip。


这时终端显示结果为：

> "mkimage" command **not found** - U-Boot images will not be built
> Image arch/arm/boot/uImage is ready

这时需要将 `mkimage` 命令添加进bin目录

``` bash
cp mkimage /bin
```
再次编译即可

### 制作文件系统

#### 建立必要文件

主要是建立一些目录，如果需要nfs启动根文件系统的话，还要加入启动文件。

``` bash
mkdir /nfsroot
mkdir bin dev etc lib proc sbin sys usr mnt tmp var
mkdir usr/bin usr/lib usr/sbin lib/modules
tar zxvf etc.tar.gz -C /nfsroot/
```
其中`etc.tar.gz`为nfs启动文件，`/nfsroot`不仅是内核模块，也为nfs共享目录，以便根文件系统通过nfs启动。

#### 编译内核模块
在内核目录下执行

``` bash
make modules ARCH=arm CROSS_COMPILE=arm-linux-
make modules_install ARCH=arm INSTALL_MOD_PATH=/nfsroot
```

#### 安装busybox
在busybox目录下，配置busybox，包括安装命令的路径等。然后编译、安装。

``` bash
make menuconfig
make ARCH=arm CROSS_COMPILE=arm-linux-
make install
```

执行

``` bash
ls /nfsroot/bin
```
如果安装成功，可以看到此目录下安装好的一些命令。


### 开发板下载

将编译好的1、uboot文件 2、zImage内核 3、cramfs根文件系统 下载到开发板中。通过 tftp 的方式来下载，关于 tftp 的配置，文章的最后有具体的介绍。

`ps：`cramfs文件为只读，yaffs文件可读写，开发时通过nfs挂载，更加便捷。


因为开发板上现在没有操作系统，不能使用Linux的命令，我们先来看一下一些 uboot 的常用命令。

``` bash
setenv 变量 值   #设置变量的值
setenv 变量      #删除变量
saveenv          #保存配置，也可以为save
printenv         #打印配置，也可以为pri
setenv bootcmd 命令    #设置启动后自动运行的命令
setenv bootargs 参数   #设置内核启动参数

#emmc指令
movi init          #初始化emmc
movi read/write uboot/kernel addr  #读/写镜像到内存地址addr中
movi read/write rootfs addr size   #读/写size大小的文件系统到内存地址addr中

#运行指令
go addr    #执行内存中addr处的指令
run var    #运行变量var制定指令
bootm kerneladdr rootfsaddr devicetreeaddr #运行kernel从地址处开始
```


#### 开发板配置
设置开发板和电脑主机的ip

``` bash
setenv serverip 192.168.0.1
setenv ipaddr 192.168.0.2
```

如果文件系统为nfs启动，则如下设置nfs启动，另外如果在编译内核是配置过，就不需要在这里设置了。

``` bash
setenv bootargs"root=/dev/nfs nfsroot=192.168.0.1:/nfsroot ip=192.168.0.2 console=ttySAC0,115200"
```

最后记得保存

``` bash
saveenv
```

#### 下载内核



首先下载uboot文件

``` bash
tftp c0008000 u-boot.bin
nand erase 0 40000
nand write c0008000 0 40000
```

下载内核

``` bash
tftp c0008000 zImage
nand erase 40000 200000
nand write c0008000 40000 200000
```

#### 下载文件系统

首先需要下载cramfs根文件系统

``` bash
tftp c0008000 rootfs_up6410.cramfs
nand erase 300000 f00000
nand write c0008000 300000 f00000
```

用户文件即yaffs文件系统，可以通过FlashFXP传送到开发板的`/tmp/`目录下，此目录掉电后文件自动删除，然后再xshell中运行

``` bash
tar jxvf /tmp/yaffs.tar.bz2 -C /mnt/yaffs/
```

如果是在开发阶段，不需要像上面那样把整个文件系统拷贝到开发板上，把需要运行的程序放在主机上的nfs共享文件夹中。假如需要在开发板上运行的程序工程在电脑上Linux的目录`/nfsroot`中，xshell上只需要运行挂载命令，在开发板的`/mnt/nfs`目录中就能看到应用程序。

``` bash
mount -t nfs 192.168.0.1:/nfsroot /mnt/nfs
```

### 其他配置

还有三个很重要的配置，`tftp`为最开始的裸机提供uboot、内核镜像和文件系统的下载，`nfs`可以理解为用来实现开发板和电脑共享文件，`samba`则为实现电脑上windows和linux之间的共享。



#### tftp配置

首先安装客户端和服务器，在线安装即可

``` bash
apt-get install tftp-hpa tftpd-hpa
```

配置tftp服务的目录，需要编辑 tftpd-hpa 文件

``` bash
vim /etc/default/tftpd-hpa
```

内容如下，其中第二行即为 tftp 目录，修改成想要设定的即可。创建的这个目录权限一般为777。

``` bash
TFTP_USERNAME="tftp"
TFTP_DIRECTORY="/tftp"
TFTP_ADDRESS="0.0.0.0:69"
TFTP_OPTIONS="-c  -s  -l"
```

最后重启服务

``` bash
service tftpd-hpa restart
```

然后将需要通过 tftp 下载到开发板上的文件放入上面的 /tftp 目录中就可以了。

#### nfs挂载文件系统

首先如果没有安装nfs服务器程序和客户端程序，则需要安装它们。安装时若提示`/etc/exports.d`目录不存在，手动创建目录即可。

``` bash
apt-get install nfs-kernel-server nfs-common
```

修改`/etc/exports`文件，设置共享目录，一般这个目录的权限设置为777。设置访问范围，即能访问nfs服务器的网段。参数 `sync` 表示修改会同步到服务器端。

``` bash
/nfsroot 192.168.0.*(rw,sync,no_root_squash)
```

重启nfs服务，如果不是像下面一样直接nfs启动，而仅仅是在启动后挂载文件，那么只需要在开发板上运行挂载命令即可。

``` bash
/etc/init.d/nfs-kernel-server restart 
```

在xshell中运行

``` bash
tftp 31000000 uImage
bootm 31000000
```

其中`uImage`是前面编译的能直接通过 nfs 启动文件系统的内核，然后重启之后自动运行能挂载nfs文件系统的镜像。

#### samba服务器

如果没有安装 samba 服务，则安装它们

``` bash
apt-get install samba
```


直接编辑 /etc/samba/ 目录下的`smb.conf`这个文件即可，加入一些配置参数，如共享路径，共享目录用户等。

``` bash
vim /etc/samba/smb.conf
```

然后重启 samba 服务

``` bash
service smbd restart
```

最后设置用户名和密码即可

``` bash
smbpasswd -a 用户名
```

我发现一个简单的方法，在Ubuntu中在需要共享的文件夹右键，然后设置共享，在windows下输入 `\\linux的ip` 就能直接访问了，不需要输入用户名和密码了。

当然和 windows 共享文件的话，除了上面的方法，使用 VMware 自带的共享设置也很方便。