---
layout:     post
title:      "并发网络服务器"
subtitle:   "基于多路复用实现"
date:       2016-05-19
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - 并发
    - socket
---

之前写过一篇文章，介绍了一种多进程实现的并发网络服务器。但要认识到每 fork() 一次，都要涉及到进程中大量的数据复制和内存占用，比较浪费系统资源。

之前也介绍过在处理并发服务方面，除了使用多进程和多线程实现外，还可以采用I/O多路复用。与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程或者线程，也不必维护这些进程或者线程，从而大大减小了系统的开销。


### 多路复用

多路复用在之前的文章详细介绍过，具体在 [Linux串口操作](http://www.eeluobu.com/blog/2016/05/16/file_io) 这篇文章里。


### 实现


#### 两个小问题


在介绍源程序前，先写两个小问题，也是我最开始学socket编程时突然发现的。

``` c
int socket(int family, int type, int protocol)
```

socket()函数的第一个family参数，书上不管是IPv4还是IPv6协议，包括其他协议，都是AF_xxxx，即都是AF开头的。今天在网上看了一个程序用的是PF开头的，以为是写错了，上网查了一下。下面是摘取网上的一段介绍：

> 在windows中AF_INET与PF_INET完全一样。而在Unix/Linux系统中，在不同的版本中这两者有微小差别。对于BSD是AF，对于POSIX是PF。理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。也就是说你socket时候用PF_xxxx，设置的时候用AF_xxxx也是没关系的。



第二个问题，服务器端接收客户端connect请求的accept()函数。

``` c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
```

accept()函数第二个参数 `*addr` 描述为客户端地址，我就很好奇，都还没连接上，怎么知道客户端的地址。而且好多程序都还在程序开始定义了一个空的客户端地址，传一个空的值进函数不是没有意义吗？原来这可以认为是函数的一个返回值，当客户端连接上后，程序会自动把客户端地址填充到参数 *addr 中。服务器程序在需要客户端ip时可以调用这个地址得到。

#### 源代码

下面直接看服务器端的源程序，一些关键的步骤在程序里面做了注释。

``` c
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <netinet/in.h>


#define MAX_QUE_CONN_NM  5
#define MAX_SOCK_FD      FD_SETSIZE
#define BUFFER_SIZE      1024

typedef struct sockaddr SA;

int main(int argc, char *argv[])
{
    struct sockaddr_in myaddr;
    fd_set inset, tmp_inset;
    int sockfd, client_fd;
    char buf[BUFFER_SIZE];
    
    if (argc < 3)
    {
        printf("Usage : %s <serv_ip> <serv_port>\n", argv[0]);
        exit(-1);
    }
    
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror("fail to socket");
        exit(-1);
    }
    
    bzero(&myaddr, sizeof(myaddr));
    myaddr.sin_family = AF_INET;
    myaddr.sin_port = htons(atoi(argv[2]));
    myaddr.sin_addr.s_addr = inet_addr(argv[1]);
    
    
    if (bind(sockfd, (SA *)&myaddr, sizeof(myaddr)) == -1)
    {
        perror("fail to bind");
        exit(-1);
    }
    
    if(listen(sockfd, MAX_QUE_CONN_NM) == -1)
    {
        perror("fail to listen");
        exit(-1);
    }
    printf("listening....\n");
    
    
    /*将调用socket函数的描述符作为文件描述符*/
    FD_ZERO(&inset);
    FD_SET(sockfd, &inset);
    
    while(1)
    {
        tmp_inset = inset;
        memset(buf, 0, sizeof(buf));
        
        /*调用select函数*/
        if (!(select(MAX_SOCK_FD, &tmp_inset, NULL, NULL, NULL) > 0))
        {
            perror("select");
            close(sockfd);
            exit(-1);
        }
        
        for (int fd = 0; fd < MAX_SOCK_FD; fd++)
        {
            if (FD_ISSET(fd, &tmp_inset) > 0) 
            {
                if (fd == sockfd)  /* 服务端接收客户端的连接请求 */
                {    
                    if ((client_fd = accept(sockfd, NULL, NULL))== -1)
                    {
                        perror("accept");
                        exit(1);
                    }
                    FD_SET(client_fd, &inset);
                    printf("New connection from %d(socket)\n", client_fd);
                }
                else /* 处理从客户端发来的消息 */
                {
                    if ((int count = recv(fd, buf, BUFFER_SIZE, 0)) > 0)
                    {
                        printf("Received a message from %d: %s\n", fd, buf);
                    }
                    else		
                    {
                        close(fd);
                        FD_CLR(fd, &inset);
                        printf("Client %d(socket) has left\n", fd);
                    }						
                }		
            } 
        } 
    } 
    
    close(sockfd);
    exit(0);
}
```


### 其他


客户端的源程序，以及网络编程的一些细节介绍可以看之前的这篇文章《[一个并发网络服务实现](http://www.eeluobu.com/blog/2016/05/15/socket)》。

至此关于Linux应用程序编程以及内核驱动编程，到2016上半年为止，就先暂时告一段落了。下面的时间主要复习一下数据结构、算法、C++和嵌入式QT，继续加油！