---
layout:     post
title:      "Linux设备驱动模型（三）"
subtitle:   "platform设备驱动模型"
date:       2016-05-03
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - linux
    - device
    - driver
    - platform
---


### 平台设备 

前面两篇介绍了字符设备、misc设备模型、bus设备模型、device设备模型和driver设备模型，这些模型都是经典的基础模型。虽然说platform模型是2.6内核开始引进的，但是ldd3中好像并没有提到这个模型。不过platform设备模型依旧是在设备驱动程序非常重要，很多驱动程序都使用这个模型。

#### 平台设备特点

下面是platform的一些特点：

> platform是一种虚拟的总线，platform驱动与传统的设备驱动模型相比，优势在于platform机制将设备**本身的资源**注册进**内核**，由内核统一管理，在驱动程序使用统一的接口去使用这些资源，提高了程序的**可移植性**。


#### 平台设备结构

``` c
struct platform_device {
    const char  *name;
    int   id;
    struct device dev;
    u32  num_resources;
    struct resource *resource;
    
    const struct platform_device_id *id_entry;
    struct mfd_cell *mfd_cell;
    struct pdev_archdata archdata;
};
```
`*name`是平台的设备名，`id`一般为-1，表示只有一个这样的平台，`dev`是设备模型，`num_resources`是平台资源数量，`*resource`是平台资源数组。

#### 平台资源

struct resource的结构如下

``` c
struct resource {
    resource_size_t start;
    resource_size_t end;
    const char *name;
    unsigned long flags;
    struct resource *parent, *sibling, *child;
};
```
`start`为开始地址，`end`为结束地址，`name`为资源名。

`flag`为资源类型，可以取值有：IORESOURCE_IO、IORESOURCE_MEM、IORESOURCE_IRQ、IORESOURCE_DMA。

一个定义平台资源的例子

``` c
static struct resource s3c_buttons_resource[] = {
    [0] = {
        .start = S3C24XX_PA_GPIO,
        .end   = S3C24XX_PA_GPIO + S3C24XX_SZ_GPIO - 1,
        .flags = IORESOURCE_MEM,
        },
    //中间省略了一些
    [6] = {
        .start = IRQ_EINT19,
        .end   = IRQ_EINT19,
        .flags = IORESOURCE_IRQ,
        }
};
```

#### 设备注册

platform_device的注册函数有：

``` c
int platform_device_add(struct platform_device *pdev);

int platform_device_register(struct platform_device *pdev);

int platform_add_devices(struct platform_device **devs, int num);
```
其中platform_device_register()函数中有对platform_device_add()的调用，感觉这两个函数差不多，前者多了一个`&pdev->dev`的初始化。

``` c
int platform_device_register(struct platform_device *pdev)
{
    device_initialize(&pdev->dev);
    return platform_device_add(pdev);
}
```
而platform_add_devices()则是对platform_device的数组进行注册，可以同时注册多个platform设备。

#### 添加资源

在注册完设备之后，如果在程序中需要使用平台资源，还要对平台资源进行注册

``` c
int platform_device_add_resources(struct platform_device *pdev,
                                   const struct resource *res, unsigned int num);
```

#### 设备注销
platform_device的注销函数：

``` c
void platform_device_unregister(struct platform_device *);
```

#### 平台设备驱动结构


``` c
struct platform_driver {
    int (*probe)(struct platform_device *);
    int (*remove)(struct platform_device *);
    void (*shutdown)(struct platform_device *);
    int (*suspend)(struct platform_device *, pm_message_t state);
    int (*resume)(struct platform_device *);
    struct device_driver driver;
    const struct platform_device_id *id_table;
};
```
一个初始化platform_driver的例子

``` c
struct platform_driver my_led_drv = { 
    .probe = my_plat_probe, 
    .remove = my_plat_remove, 
    .driver = { 
        .owner = THIS_MODULE, 
        .name = "platform_led", 
    }, 
}; 
```

#### 驱动注册

platform_driver注册函数：

``` c
int platform_driver_register(struct platform_driver *drv);
```
在注册成功之后，内核会自动的运行`platform_match()`函数将设备和驱动进行匹配。

``` c
int platform_match(struct device *dev, struct device_driver *drv)
{
    struct platform_device *pdev = to_platform_device(dev);
    struct platform_driver *pdrv = to_platform_driver(drv);
    if (of_driver_match_device(dev, drv))
        return 1;
    if (pdrv->id_table)
        return platform_match_id(pdrv->id_table, pdev) != NULL;
    return (strcmp(pdev->name, drv->name) == 0);
}
```

#### 驱动注销

platform_driver的注销函数：

``` c
void platform_driver_unregister(struct platform_driver *drv);
```

### 例子程序

int my_plat_probe(struct platform_device *dev) 

#### 模块init函数

``` c
/*platform_device*/
my_led_dev = platform_device_alloc("platform_led", -1); 
platform_device_add(my_led_dev);

/*platform_driver*/
platform_driver_register(&my_led_drv);
```

#### 模块exit函数

``` c
/*platform_driver*/
platform_driver_unregister(&my_led_drv);

/*platform_device*/
platform_device_unregister(my_led_dev);
```


#### 其他实现

首先要实现platform_driver结构

``` c
struct platform_driver my_led_drv = { 
    .probe = my_plat_probe, 
    .remove = my_plat_remove, 
    .driver = { 
        .owner = THIS_MODULE, 
        .name = "platform_led", 
    }, 
}; 
```

然后实现其中的`probe`和`remove`函数。

##### probe函数

按照经验的话，一般在probe函数中就是`注册设备`了，比如前面的字符设备，misc设备。注册设备之前，1：实现file_operations结构；2：实现file_operations结构中的open、close、read、write等函数。在实现这些函数的时候，可能还会用到平台资源，这时候就需要调用`platform_get_resource()`函数获得资源，然后来实现相应的功能了。

**获得平台资源**

``` c
struct resource *platform_get_resource(struct platform_device *dev,
                                      unsigned int type, unsigned int num)
```

##### remove函数

remove函数就比较简单了，释放一些资源，注销probe中注册的设备。

### 小结

到这里，一个完整的平台设备驱动程序就算基本实现了，当然中间还有很多细节需要完善的地方。

用了三篇来写Linux设备驱动模型，感觉自己又理解、学习了很多。掌握这些框架式的设备模型，虽然不能让我们精确的写出一个设备驱动程序，但是在掌握熟悉了这些设备模型的构架之后，能让我们很容易的看懂Linux内核的驱动程序，再到自己设计或者改写内核驱动程序，就很容易了。