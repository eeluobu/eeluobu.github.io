---
layout:     post
title:      "基础数据结构（二）"
subtitle:   "哈希表、树、图"
date:       2016-05-23
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - structure
---

### 二叉树

每个结点的度都不大于2，每个结点的孩子结点次序不能颠倒，这样的树称之为二叉树。下面是关于二叉树的一些性质：

- 在二叉树的第 n 层至多有 2ⁿ⁻¹ 个结点；

- 深度为 n 的二叉树至多有 2ⁿ-1 个结点；

- 对于一颗二叉树，若终端结点的数量为n₀，度为2的结点数量为n₂，则n₀ = n₂ + 1。

当然根据二叉树的特性，还可以总结出很多其他相关的性质或者规律，就没有一一列举了。

二叉树的存储可以有顺序和链式的结构。顺序结构即用数组来存储元素，对于完全二叉树比较方便，但对于一般的二叉树来说就比较浪费资源了。下面主要介绍的都是基于链式存储结构的二叉树。


``` c
typedef struct node
{
    int data;
    struct node *lchild;
    struct node *rchild;
} tree;
```


#### 二叉树遍历

遍历算法很有用，比如输出二叉树的结点、叶子结点，统计结点、叶子结点的数目等。

先序遍历


``` c
void Pre(tree root)
{
    if(root != NULL)
    {
        Visit(root->data);  //访问根结点函数
        Pre(root->lchild);
        Pre(root->rchild);
    }
}
```

中序遍历

``` c
void In(tree root)
{
    if(root != NULL)
    {
        In(root->lchild);
        Visit(root->data);
        In(root->rchild);
    }
}
```


后序遍历

``` c
void Post(tree root)
{
    if(root != NULL)
    {
        Post(root->lchild);
        Post(root->rchild);
        Visit(root->data);
    }
}
```


中序遍历二叉树的非递归算法

``` c
void In(tree root)
{
    InitStack(&S);  //初始化栈一个空栈S
    p = root;
    while(p != NULL || !Empty(S))
    {
        if(p != NULL)
        {
            Push(&S, p);
            p = p->lchild;
        }
        else
        {
            Pop(&S, &p);
            Visit(p->data);
            p = p->rchild;
        }
    }
}
```

### 二叉树相关排序

#### 二叉排序树

#### 平衡二叉排序树



#### B树




### 哈夫曼树

#### 哈夫曼编码

### 图


图算是比较复杂的数据结构了，面试的时候一般在编程大题里面才会出现，下面介绍一些基本操作。




#### 存储结构


邻接矩阵


邻接表



#### 图的遍历


深度优先搜索


广度优先搜索



#### 应用


Dijkstra算法：


dijkstra算法为单源最短路径算法，计算了从源点到其他所有结点的最短路径。要求图中不存在负权边。

寻找源结点v0到每一个结点的最短路径：

(1) 初始化，S = {v0}，所有不在S中的结点v，求出D(v)，即结点v0到v的距离l(v0,v)，不存在的用∞表示。  
(2) 找到一个不在S中的w，D(w)最小，把w加入到S中。剩下的不在S中的结点v，用min(D(v), D(w)+l(w,v))替换D(v)。  
(3) 重复步骤(2)，直到所有的网络结点都在S中。这时结点v0到图中每一个结点的最短路径都存在了D(v)中。






``` c
int dis[MA];
int pre[MA];

int a[MA][MA];


//v0为要计算的第一个结点
void Dijkstra(int v0)
{
    int n = MA;
    bool S[MA];     //判断是否已存入S集合中
    for(int i = 1; i <= n; i++)
    {
        dis[i] = a[v0][i];
        S[i] = false;
        if(dis[i] == MA)
            pre[i] = -1;
        else
            pre[i] = v0;
    }
    dis[v0] = 0;
    S[v0] = true;
    
    for(int i = 2; i <= n; i++)
    {
        int min = MA;
        int u = v0;
        for(int j = 1; j <= n; j++)
        {
            if((!S[j]) && dis[j] < min)
            {
                u = j;
                min = dis[j];
            }
        }
        
        S[u] = true;
        
        for(int j = 1; j <= n; j++)
        {
            if((!S[j]) && a[u][j] < MA)
            {
                if(dis[u] + a[u][j] < dis[j])
                {
                    dis[j] = dis[u] + a[u][j];
                    pre[j] = u;
                }
            }
        }
    }
}
        
```





Floyd算法：

Floyd-Warshall算法求任意两点间的最短路径，可以处理有向图或者负权的最短路径。
时间复杂度O(N<sup>3</sup>)，空间复杂度O(N<sup>2</sup>)


求a、b两点的最短距离：

假设是a、b两点之间有k结点，ab的距离D(ab)，开始遍历节点k，当D(ak)+D(kb)<D(ab)时，更新D(ab)=D(ak)+D(kb)，
当遍历完k时，D(ab)就是a、b两点的最短距离。




``` c
//图的邻接矩阵
int edges[][];

void Floyd(int edges[][])
{
    int a[MA][MA];
    int path[MA][MA];
    int i,j,k;
    int n = MA;
    
    for(i = 0; i < n; i++)
        for(j = 0; j < n; j++)
        {
            a[i][j] = edges[i][j];
            path[i][j] = -1;
        }
        
    for(k = 0; k < n; k++)
        for(i = 0; i < n; i++)
            for(j = 0; j < n; j++)
                if(a[i][j] > (a[i][k] + a[k][j]))
                {
                    a[i][j] = a[i][k] + a[k][j];
                    path[i][j] = k;
                }
}
```




