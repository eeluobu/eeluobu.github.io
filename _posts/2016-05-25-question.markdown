---
layout:     post
title:      "Interview常见问题"
subtitle:   "一些基础问题，持续更新"
date:       2016-05-25
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - 网络
    - 内存
    - 指针
---


#### 网络相关

报文格式中的一些参数：  
序号：seq，32位  
确认序号：ack，32位（接收到的序号seq+1，也即下一次接收到的序号）  
标志位：  
ACK：确认序号有效  
SYN：发起一个连接  
FIN：释放一个连接  


tcp的三次握手和四次挥手：

握手  

|   客户端   |         过程         | 服务器端 | 
| :--------: | :------------------: | :------: |
|            | --------SYN=1 seq=J--------> |          |
|            | <-----SYN=1,ACK=1 ack=J+1,seq=K----- |          |
|            | --------ACK=1 ack=K+1--------> |          |

挥手


|   客户端   |         过程         | 服务器端 | 
| :--------: | :------------------: | :------: |
|            | --------FIN=1 seq=M--------> |          |
|            | <------ DATA ------> |          |
|            | <------ACK=1 ack=M+1---------  |          |
|            | <------ FIN=1 seq=N-------- |          |
|            | --------ACK=1 ack=N+1--------> |          |




【问题一】为什么连接的时候是三次握手，关闭的时候却是四次握手

因为当server端收到client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉client端收到了FIN报文。只有等到server端所有的报文都发送完了，才能发送给client端一个FIN报文，因此不能一起发送。故需要四步握手。


#### 内存对齐

一个空类的空间为1，单一继承和多重继承的空类也是1，但是虚继承涉及到虚表，大小为4

``` c
class A {};
class A1 {};
class B : public A {};
class C : public virtual A {};
class D : public A, public A2 {};

//sizeof(A) = 1
//sizeof(B) = 1
//sizeof(C) = 4
//sizeof(A) = 1
```



#### 分配内存和释放

分配内存的函数和释放的要匹配

``` c
char *a = new char[n];
delete[] a;

char *a = malloc(n*sizeof(char));
free(a);
```



分配内存函数

``` c
//指向指针的指针
void getmemory(char **p, int num)
{
    *p = (char *) malloc(sizeof(char) * num);
}

char *str = NULL;
getmemory(&str, 100);
```

``` c
//返回分配好的内存地址
char *getmemory(char *p, inr num)
{
    p = (char *) malloc(sizeof(char) * num);
    return p;
}

char *str = NULL;
str = getmemory(str, 100);
```



指针和引用

``` c
int &a;  //错误，引用不能为空

const int b;  //错误，常量赋值同时需初始化
```

#### 字符串


常用的sizeof和strlen


``` c
char *s1 =     "0123456789";   //全局，常量
char s2[] =    "0123456789";   //局部，变量，下同
char s3[100] = "0123456789";
int s4[100] =  "0123456789";
```

``` c
// s1
sizeof(s1) = 4;    //指针大小，相当于sizeof(char *)
sizeof(*s1) = 1;   //第一个字符的大小，相当于sizeof(char)
strlen(s1) = 未知; //没有分配空间，不知道'\0'的位置

// s2
sizeof(s2) = 11; //数组空间大小，包含'\0'在内
sizeof(*s2) = 1;  //同s1原理
strlen(s2) = 10; //不包含'\0'

// s3
sizeof(s3) = 100;  //数组空间大小
strlen(s3) = 10;   //数组元素个数，不包含'\0'

// s4
sizeof(s4) = 400;  //数组空间大小4x100
sizeof(*s4) = 4;    //第一个字符的大小，相当于sizeof(int)
strlen(s4) = 出错; //strlen()只能用于char类型
```



``` c
//c1(a, b) 不能实现交换
void c1(int a, int b)
{
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}

//c2(&a, &b)
void c2(int *a, int *b)   
{
    *a = *a ^ *b;
    *b = *a ^ *b;
    *a = *a ^ *b;
    //定义一个temp交换，而不是*temp
}

//c3(a, b)
void c3(int &a, int &b)
{
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}
```



#### static


定义全局变量就可以实现变量在文件中的共享（其他文件使用extern修饰），但定义静态全局变量还有以下好处：
1、静态全局变量不能被其它文件所用；
2、其它文件中可以定义相同名字的变量，不会发生冲突；

静态局部变量有以下特点：
1、该变量在全局数据区分配内存；
2、静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；

定义静态函数的好处：
1、静态函数不能被其它文件所用；
2、其它文件中可以定义相同名字的函数，不会发生冲突；