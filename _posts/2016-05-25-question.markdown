---
layout:     post
title:      "Interview常见问题"
subtitle:   "一些基础问题，持续更新"
date:       2016-05-25
author:     "luobu"
header-img: "img/post.jpg"
catalog:    true
tags:
    - 网络
    - 内存
    - 指针
---


#### 网络相关

报文格式中的一些参数：  
序号：seq，32位  
确认序号：ack，32位（接收到的序号seq+1，也即下一次接收到的序号）  
标志位：  
ACK：确认序号有效  
SYN：发起一个连接  
FIN：释放一个连接  


tcp的三次握手和四次挥手：

握手  

|   客户端   |         过程         | 服务器端 | 
| :--------: | :------------------: | :------: |
|            | --------SYN=1 seq=J--------> |          |
|            | <-----SYN=1,ACK=1 ack=J+1,seq=K----- |          |
|            | --------ACK=1 ack=K+1--------> |          |

挥手


|   客户端   |         过程         | 服务器端 | 
| :--------: | :------------------: | :------: |
|            | --------FIN=1 seq=M--------> |          |
|            | <------ DATA ------> |          |
|            | <------ACK=1 ack=M+1---------  |          |
|            | <------ FIN=1 seq=N-------- |          |
|            | --------ACK=1 ack=N+1--------> |          |




【问题一】为什么连接的时候是三次握手，关闭的时候却是四次握手

因为当server端收到client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步建立一个新的连接的。但是关闭连接时，当server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉client端收到了FIN报文。只有等到server端所有的报文都发送完了，才能发送给client端一个FIN报文，因此不能一起发送。故需要四步握手。


OSI模型的七层结构

|      七层结构       |        数据格式            | 功能和连接方式                       | 典型设备   | 
| :---------------    | :------------------        | :------                              | :--------- |
| 应用层application   | 数据data                   | 网络服务与使用者应用程序间的一个接口 | 终端设备   |
| 表示层presentation  | 数据data                   | 数据表示、数据安全、数据压缩         | 终端设备   |
| 会话层session       | 数据data                   | 会话层连接到传输层映射、流量控制、数据传输、恢复与释放、差错控制  | 终端设备 |
| 传输层transport     | 数据组织成数据段segment    | 用一个寻址机制标识一个特定的应用程序（端口号）        | 终端设备 |
| 网络层network       | 分割和重新组合数据包packet | 基于IP地址进行不同的网络系统间的路径选择       | 路由器 |
| 数据链路层data link | 将bit信息封装成数据帧frame | 在物理层上建立、撤销、标识逻辑链接和链路复用。使用接收系统的硬件物理地址寻址 | 网桥、网卡、二层交换机 |
| 物理层physical      | 传输bit流                  | 建立、维护和取消物理连接                                   | 光纤、网线、中继器、集线器 |



TCP/IP模型四层结构

| 四层结构   |  协议                    | 
| :--------  | :--------------          |
| 应用层     | DNS FTP HTTP TELNET SMTP |
| 传输层     | TCP UDP                  |
| 互联层     | IP IGMP ICMP             | 
| 网络接口层 | ARP                      |

IGMP：互联网组管理协议  
ICMP: 互联网控制报文协议  
ARP：地址解析协议






#### 内存对齐

一个空类的空间为1，单一继承和多重继承的空类也是1，但是虚继承涉及到虚表，大小为4

``` c
class A {};
class A1 {};
class B : public A {};
class C : public virtual A {};
class D : public A, public A2 {};

//sizeof(A) = 1
//sizeof(B) = 1
//sizeof(C) = 4
//sizeof(A) = 1
```



#### 分配内存和释放

分配内存的函数和释放的要匹配

``` c
char *a = new char[n];
delete[] a;

char *a = malloc(n*sizeof(char));
free(a);
```



分配内存函数

``` c
//指向指针的指针
void getmemory(char **p, int num)
{
    *p = (char *) malloc(sizeof(char) * num);
}

char *str = NULL;
getmemory(&str, 100);
```

``` c
//返回分配好的内存地址
char *getmemory(char *p, inr num)
{
    p = (char *) malloc(sizeof(char) * num);
    return p;
}

char *str = NULL;
str = getmemory(str, 100);
```



指针和引用

``` c
int &a;  //错误，引用不能为空

const int b;  //错误，常量赋值同时需初始化
```

#### 字符串


常用的sizeof和strlen


``` c
char *s1 =     "0123456789";   //全局，常量
char s2[] =    "0123456789";   //局部，变量，下同
char s3[100] = "0123456789";
int s4[100] =  "0123456789";
```

``` c
// s1
sizeof(s1) = 4;    //指针大小，相当于sizeof(char *)
sizeof(*s1) = 1;   //第一个字符的大小，相当于sizeof(char)
strlen(s1) = 未知; //没有分配空间，不知道'\0'的位置

// s2
sizeof(s2) = 11; //数组空间大小，包含'\0'在内
sizeof(*s2) = 1;  //同s1原理
strlen(s2) = 10; //不包含'\0'

// s3
sizeof(s3) = 100;  //数组空间大小
strlen(s3) = 10;   //数组元素个数，不包含'\0'

// s4
sizeof(s4) = 400;  //数组空间大小4x100
sizeof(*s4) = 4;    //第一个字符的大小，相当于sizeof(int)
strlen(s4) = 出错; //strlen()只能用于char类型
```



``` c
//c1(a, b) 不能实现交换
void c1(int a, int b)
{
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}

//c2(&a, &b)
void c2(int *a, int *b)   
{
    *a = *a ^ *b;
    *b = *a ^ *b;
    *a = *a ^ *b;
    //定义一个temp交换，而不是*temp
}

//c3(a, b)
void c3(int &a, int &b)
{
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}
```



#### static


定义全局变量就可以实现变量在文件中的共享（其他文件使用extern修饰）；静态全局变量不能被其它文件所用，但其它文件中可以定义相同名字的变量，不会发生冲突。

静态局部变量有以下特点：  
1、该变量在全局数据区分配内存；  
2、静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；

定义静态函数的好处：  
1、静态函数不能被其它文件所用；  
2、其它文件中可以定义相同名字的函数，不会发生冲突；